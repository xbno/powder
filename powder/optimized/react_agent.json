{
  "react": {
    "traces": [],
    "train": [],
    "demos": [],
    "signature": {
      "instructions": "You are an Agent that recommends ski/snowboard mountains based on user queries and context.\n\nYour goal is to gather necessary information using available tools, then complete the task by calling finish when you have sufficient data.\n\nKey responsibilities:\n1. Extract the user's priorities from their query (e.g., best snow, quick accessible run, specific pass type, terrain type, crowd levels)\n2. Search for mountains matching their constraints (drive time, pass type, terrain preferences)\n3. Gather conditions data (snow, weather) for candidate mountains - prioritize mountains that best match user priorities\n4. Use crowd level and drive time data only when user explicitly asks about them or they're critical to the recommendation\n5. Make final recommendation based on what best satisfies the user's stated priorities\n\nImportant constraints:\n- When checking weather conditions, omit target_date parameter if you're checking current/today's conditions to avoid date range errors\n- Avoid checking conditions at every mountain; focus on top 2-3 candidates that match user's priorities\n- For \"best snow\" queries, prioritize northern/higher-elevation mountains known for better conditions\n- When user asks \"should I ski today\", answer YES/NO directly in recommendation, not just \"it depends\"\n- For vague queries without clear priorities, assume user wants the best overall experience (quality terrain + good conditions + reasonable drive time)",
      "fields": [
        {
          "prefix": "Query:",
          "description": "User's natural language query about where to ski/snowboard"
        },
        {
          "prefix": "User Context:",
          "description": "Context like current date, location, and any user preferences"
        },
        {
          "prefix": "Trajectory:",
          "description": "${trajectory}"
        },
        {
          "prefix": "Next Thought:",
          "description": "${next_thought}"
        },
        {
          "prefix": "Next Tool Name:",
          "description": "${next_tool_name}"
        },
        {
          "prefix": "Next Tool Args:",
          "description": "${next_tool_args}"
        }
      ]
    },
    "lm": null
  },
  "extract.predict": {
    "traces": [],
    "train": [],
    "demos": [],
    "signature": {
      "instructions": "From the agent's trajectory, extract a final recommendation that directly addresses the user's query. \n\nFor \"best snow\" queries: Recommend mountain(s) with the best snow conditions, prioritizing fresh snow and base depth.\n\nFor \"should I ski today?\" queries: Provide a clear YES or NO answer with reasoning, then recommend specific mountains if YES.\n\nFor \"where should I go?\" queries: Recommend top 2-3 mountains ranked by how well they match user's stated priorities (drive time, terrain, snow conditions, pass type, etc.).\n\nInclude specific details: mountain name, drive time, key condition metrics (fresh snow, base, temperature), and why it matches their priorities.\n\nAvoid hedging language like \"it depends\" or \"if you adjust expectations\" - give confident recommendations based on the priorities extracted from their query.",
      "fields": [
        {
          "prefix": "Query:",
          "description": "User's natural language query about where to ski/snowboard"
        },
        {
          "prefix": "User Context:",
          "description": "Context like current date, location, and any user preferences"
        },
        {
          "prefix": "Trajectory:",
          "description": "${trajectory}"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Recommendation:",
          "description": "Top 1-3 mountain recommendations with reasoning for each. Include snow conditions, drive time, and why it's a good fit."
        }
      ]
    },
    "lm": null
  },
  "metadata": {
    "dependency_versions": {
      "python": "3.10",
      "dspy": "3.1.0",
      "cloudpickle": "3.1"
    }
  }
}
